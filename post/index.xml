<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on Yet another computer science blog</title>
    <link>https://asolda.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on Yet another computer science blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 05 Dec 2016 14:42:46 +0100</lastBuildDate>
    <atom:link href="https://asolda.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The day I found out my computer does drugs</title>
      <link>https://asolda.github.io/post/deepdream/</link>
      <pubDate>Mon, 05 Dec 2016 14:42:46 +0100</pubDate>
      
      <guid>https://asolda.github.io/post/deepdream/</guid>
      <description>

&lt;h1 id=&#34;exploring-the-unknown&#34;&gt;Exploring the unknown&lt;/h1&gt;

&lt;p&gt;In this article we will talk about &lt;strong&gt;deep convolutional neural network&lt;/strong&gt;, a.k.a. how computers are going to rule the world.
Someday. Eventually. Definetely not right now, mostly because I&amp;rsquo;ve come to the realization that my computer is constantly high on some weird acid.
More on this later. For now, let&amp;rsquo;s just understand that we are going to talk about complex topics, that this article isn&amp;rsquo;t meant for everyone out there and that I won&amp;rsquo;t have the time to explain everithing I say&amp;hellip;
I just hope you&amp;rsquo;ll follow through.&lt;/p&gt;

&lt;h2 id=&#34;what-are-we-doing&#34;&gt;What are we doing?&lt;/h2&gt;

&lt;p&gt;We want to take a look at what deep convolutional neural networks (convnets) really learn, and how they understand the images we feed them.&lt;/p&gt;

&lt;p&gt;We will use &lt;a href=&#34;https://keras.io/&#34;&gt;Keras&lt;/a&gt;, a Deep Learning library for &lt;a href=&#34;http://deeplearning.net/software/theano/&#34;&gt;Theano&lt;/a&gt; and &lt;a href=&#34;https://www.tensorflow.org/&#34;&gt;TensorFlow&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Keras&lt;/strong&gt; is a high-level neural networks library, written in Python and capable of running on top of either TensorFlow or Theano.
It was developed with a focus on enabling fast experimentation, allowing researchers to &amp;ldquo;&lt;em&gt;go from idea to result with the least possible delay&lt;/em&gt;&amp;rdquo;.
It is a really interesting project and can be extremely useful.
In this post I will be using &lt;strong&gt;Keras&lt;/strong&gt; on top of &lt;strong&gt;TensorFlow&lt;/strong&gt;, but the code can be seamlessy adapted to work on top of Theano if you prefer.&lt;/p&gt;

&lt;p&gt;We will use Keras to visualize inputs that maximize the activation of the filters in different layers of the VGG16 architecture, trained on &lt;a href=&#34;http://www.image-net.org/&#34;&gt;ImageNet&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&#34;visualizing-convnet-filters&#34;&gt;Visualizing convnet filters&lt;/h1&gt;

&lt;p&gt;VGG16 (also called OxfordNet) is a convolutional neural network architecture named after the &lt;a href=&#34;http://www.robots.ox.ac.uk/~vgg/&#34;&gt;Visual Geometry Group&lt;/a&gt; from Oxford, who developed it.
It was used to win the &lt;a href=&#34;http://www.robots.ox.ac.uk/~vgg/research/very_deep/&#34;&gt;ILSVR (ImageNet) competition in 2014&lt;/a&gt;.
To this day is it still considered to be an excellent vision model, although it has been somewhat outperformed by more recent advances (Inception, ResNet).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.lorenzobaraldi.com/&#34;&gt;Lorenzo Baraldi&lt;/a&gt; ported the pre-trained Caffe version of VGG16 (as well as VGG19) to a Keras weights file, so we will just load that to do our experiments. You can download the weight file &lt;a href=&#34;https://gist.github.com/baraldilorenzo/07d7802847aaad0a35d3&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Loading the model is made easy by Keras:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# build the VGG16 network with ImageNet weights
model = vgg16.VGG16(weights=&#39;imagenet&#39;, include_top=False)
print(&#39;Model loaded.&#39;)

model.summary()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yup, it&amp;rsquo;s &lt;strong&gt;that&lt;/strong&gt; easy. Moving along, we prepare a couple of utilities that we will need later:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;placeholder&lt;/strong&gt; (&lt;a href=&#34;https://www.tensorflow.org/versions/r0.12/api_docs/python/io_ops.html&#34;&gt;read the doc&lt;/a&gt; if you&amp;rsquo;re confused):&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# this is the placeholder for the input images
input_img = model.input
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A &lt;strong&gt;dictionary&lt;/strong&gt; that we will use to create &lt;em&gt;ad-hoc&lt;/em&gt; loss functions:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# get the symbolic outputs of each &amp;quot;key&amp;quot; layer (we gave them unique names).
layer_dict = dict([(layer.name, layer) for layer in model.layers[1:]])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;A utility function to &lt;strong&gt;normalize&lt;/strong&gt; a Tensor (using its L2 Norm)&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;def normalize(x):
    return x / (K.sqrt(K.mean(K.square(x))) + 1e-5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Moving to the interesting part of the code, it&amp;rsquo;s now time to scan through the filters, compute the loss functions and visualize the most interesting filters.
The scanning process is pretty straightforward:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;kept_filters = []
for filter_index in range(0, 200):
    # we only scan through the first 200 filters,
    # but there are more (512)
    print(&#39;Processing filter %d&#39; % filter_index)
    start_time = time.time()

    # we build a loss function that maximizes the activation
    # of the nth filter of the layer considered
    layer_output = layer_dict[layer_name].output
    if K.image_dim_ordering() == &#39;th&#39;:
        loss = K.mean(layer_output[:, filter_index, :, :])
    else:
        loss = K.mean(layer_output[:, :, :, filter_index])

    # we compute the gradient of the input picture wrt this loss
    grads = K.gradients(loss, input_img)[0]

    # normalization trick: we normalize the gradient
    grads = normalize(grads)

    # this function returns the loss and grads given the input picture
    iterate = K.function([input_img], [loss, grads])

    # step size for gradient ascent
    step = 1.

    # we start from a gray image with some random noise
    if K.image_dim_ordering() == &#39;th&#39;:
        input_img_data = np.random.random((1, 3, img_width, img_height))
    else:
        input_img_data = np.random.random((1, img_width, img_height, 3))
    input_img_data = (input_img_data - 0.5) * 20 + 128

    # we run gradient ascent for 20 steps
    for i in range(20):
        loss_value, grads_value = iterate([input_img_data])
        input_img_data += grads_value * step

        print(&#39;Current loss value:&#39;, loss_value)
        if loss_value &amp;lt;= 0.:
            # some filters get stuck to 0, we can skip them
            break

    # decode the resulting input image
    if loss_value &amp;gt; 0:
        img = deprocess_image(input_img_data[0])
        kept_filters.append((img, loss_value))
    end_time = time.time()
    print(&#39;Filter %d processed in %ds&#39; % (filter_index, end_time - start_time))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is well commented and Keras makes everything extremely linear and readable.
Just a couple of notes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;code&gt;loss function&lt;/code&gt; is easy, but effective for our purpose.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &amp;ldquo;&lt;em&gt;normalization trick&lt;/em&gt;&amp;rdquo; is worth pointing out, start your research from &lt;a href=&#34;http://stats.stackexchange.com/questions/22568/difference-in-using-normalized-gradient-and-gradient&#34;&gt;here&lt;/a&gt; if you are interested.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The &lt;code&gt;deprocess_image&lt;/code&gt; function can be a little bit tricky, but here you are:&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# util function to convert a tensor into a valid image
def deprocess_image(x):
    # normalize tensor: center on 0., ensure std is 0.1
    x -= x.mean()
    x /= (x.std() + 1e-5)
    x *= 0.1

    # clip to [0, 1]
    x += 0.5
    x = np.clip(x, 0, 1)

    # convert to RGB array
    x *= 255
    if K.image_dim_ordering() == &#39;th&#39;:
        x = x.transpose((1, 2, 0))
    x = np.clip(x, 0, 255).astype(&#39;uint8&#39;)
    return x
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;layer_name&lt;/code&gt; variable should look like this:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# the name of the layer we want to visualize
# (see model definition at keras/applications/vgg16.py)
layer_name = &#39;block5_conv1&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can now move on to select the &amp;ldquo;best&amp;rdquo; layers;
the filters that have the highest loss are supposed to be the best looking:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# we will stich the best 64 filters on a 8 x 8 grid.
n = 8

# we will only keep the top 64 filters.
kept_filters.sort(key=lambda x: x[1], reverse=True)
kept_filters = kept_filters[:n * n]

# build a black picture with enough space for
# our 8 x 8 filters of size 128 x 128, with a 5px margin in between
margin = 5
width = n * img_width + (n - 1) * margin
height = n * img_height + (n - 1) * margin
stitched_filters = np.zeros((width, height, 3))

# fill the picture with our saved filters
for i in range(n):
    for j in range(n):
        img, loss = kept_filters[i * n + j]
        stitched_filters[(img_width + margin) * i: (img_width + margin) * i + img_width,
                         (img_height + margin) * j: (img_height + margin) * j + img_height, :] = img

# save the result to disk
imsave(&#39;stitched_filters_%dx%d.png&#39; % (n, n), stitched_filters)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# dimensions of the generated pictures for each filter.
img_width = 128
img_height = 128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the image we are getting is this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://asolda.github.io/images/filters.png&#34; alt=&#34;block5_conv1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We can obviously use this code to visualize different filters for each layer.
If you do this, you will notice that the first layers basically just encode direction and color.
These direction and color filters then get combined into basic grid and spot textures.
These textures gradually get combined into increasingly complex patterns.&lt;/p&gt;

&lt;p&gt;In the highest layers (like the one above) we start to recognize textures similar to that found in the objects that network was trained to classify, such as feathers, eyes, etc.&lt;/p&gt;

&lt;p&gt;Another fun thing to do is to apply these filters to photos (rather than to noisy all-gray inputs).
This is the principle of &lt;a href=&#34;https://en.wikipedia.org/wiki/DeepDream&#34;&gt;Deep Dreams&lt;/a&gt;, popularized by Google last year.&lt;/p&gt;

&lt;p&gt;We will learn how to implement Deep Dream in the next article, in the meanwhile you can have fun visualizing different layers and using photos as a starting point for filters visualization.&lt;/p&gt;

&lt;h1 id=&#34;summary&#34;&gt;Summary&lt;/h1&gt;

&lt;p&gt;The key message here is that &lt;strong&gt;convnets don&amp;rsquo;t understand concepts&lt;/strong&gt; just because thay are able to classify objects.
The visual decomposition of visual space learned by a convnet is (apparently) analogous to what the human visual cortex does.
It may or may not be true. So what do they understand? Basically two things:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;They understand a &lt;strong&gt;decomposition of their visual input space&lt;/strong&gt; as a hierarchical-modular network of convolution filters.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;They understand a &lt;strong&gt;probabilitistic mapping between certain combinations of these filters&lt;/strong&gt; and a set of arbitrary labels.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Naturally, this does not qualify as &amp;ldquo;seeing&amp;rdquo; in any human sense, and it doesn&amp;rsquo;t mean we have solved computer vision.&lt;/p&gt;

&lt;p&gt;That said, visualizing what convnets learn is quite fascinating.
Deep learning may not be intelligence in any real sense, but it&amp;rsquo;s still working considerably better than anybody could have anticipated just a few years ago.
Guess it&amp;rsquo;s about time someone figures out &lt;strong&gt;why&lt;/strong&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How Hugo turned me into a blogger wannabe</title>
      <link>https://asolda.github.io/post/Welcome/</link>
      <pubDate>Thu, 01 Dec 2016 15:13:03 +0100</pubDate>
      
      <guid>https://asolda.github.io/post/Welcome/</guid>
      <description>

&lt;h1 id=&#34;what-is-this&#34;&gt;What is this?&lt;/h1&gt;

&lt;p&gt;I have decided to finally start a blog. This is just a welcome message (mostly realized to test Hugo, Github Pages and a few themes).
In this blog I will talk about the project I work on in my free time; topics range from machine/deep learning to social network analysis, distributed computing and more.
Some projects are my own ideas, others are the result of me playing with coll stuff you find around the web.
This first article is about the technical details behind the blog itself, what technologies I&amp;rsquo;m using, how I&amp;rsquo;ve set up my workflow and how hugo convinced me to start this.&lt;/p&gt;

&lt;h1 id=&#34;about-this-article&#34;&gt;About this article&lt;/h1&gt;

&lt;p&gt;This is supposed to be a technical blog, a safe shelter for computer scientists and alikes.
How I am developing this blog can be interesting and usefull for other people who want to share their projects and their knowledge.
The idea here is to give you an overview of how I am developing and updating the blog from a technical perspective.&lt;/p&gt;

&lt;h2 id=&#34;resources&#34;&gt;Resources&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt;, alongside &lt;a href=&#34;https://pages.github.com/&#34;&gt;Github Pages&lt;/a&gt;, are the main reasons why I have finally decided to start this project.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Hugo&lt;/strong&gt; is &amp;ldquo;&lt;em&gt;a fast and modern static website engine&lt;/em&gt;&amp;rdquo;. That is, a &lt;strong&gt;HUGE&lt;/strong&gt; help when you want to just write your thoughs, without worrying about themes, styles, and general web-development-related issues.
It is easy to install and configure (short tutorial is down the road), light, fast (gotta love &lt;a href=&#34;https://golang.org/&#34;&gt;go&lt;/a&gt;), open source&amp;hellip; I could go on for miles.
There are downsides and negative aspects too, but the moment you realize what Hugo is meant for you also realize that negative aspects turn into features; you will realize this in a few weeks of usage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Github Pages&lt;/strong&gt; allows you to create and publish websites for your projects, as well as personal blogs or portfolios.
The code for you site is hosted directly from your GitHub repository. Just edit, push, and your changes are live.&lt;/p&gt;

&lt;p&gt;The way Hugo and Github Pages interact is mesmerizing; this instruments team up for a produtictivity boost comparable to the introductions of rounded wheels over squared ones.
Damn, you gotta love this things; and to bring you on board with me, let&amp;rsquo;s dive into a tutorial on how to setup this workflow.&lt;/p&gt;

&lt;p&gt;Please note that I will assume that you already use git. In case you don&amp;rsquo;t, &lt;a href=&#34;https://git-scm.com/book/en/v2/Getting-Started-Installing-Git&#34;&gt;here you are&lt;/a&gt; (and you&amp;rsquo;re a bad person).&lt;/p&gt;

&lt;h1 id=&#34;let-s-start-the-party&#34;&gt;Let&amp;rsquo;s start the party&lt;/h1&gt;

&lt;h2 id=&#34;step-0-install-and-configure-hugo&#34;&gt;Step 0: Install and configure Hugo&lt;/h2&gt;

&lt;p&gt;You only need to follow this steps the first time you use Hugo. Since it is written in go, it supports multiple platforms and comes in pre-built binaries available &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;A complete installation guide is available &lt;a href=&#34;https://gohugo.io/overview/installing/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re on a Mac, I advice you install &lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt; and just &lt;code&gt;brew install hugo&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;before-you-start&#34;&gt;Before you start&lt;/h3&gt;

&lt;p&gt;If you haven&amp;rsquo;t already done that, check that Hugo is correctly configured by running&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo help
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You should see something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.

Usage:
  hugo [flags]
  hugo [command]
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It goes on for a while.&lt;/p&gt;

&lt;h2 id=&#34;step-1-create-your-first-hugo-project&#34;&gt;Step 1: Create your first Hugo project&lt;/h2&gt;

&lt;p&gt;In this short example we will create a blog.&lt;/p&gt;

&lt;p&gt;Hugo has a large set of commands to manage your website. To create a new website move to a convenient location and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new site blog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Change directory to &lt;code&gt;blog&lt;/code&gt; and you will see that Hugo has created directories to store all the files required for your website.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x  2 user   68 Nov 30 23:58 archetypes
-rw-r--r--  1 user   97 Dec  1 00:22 config.toml
drwxr-xr-x  3 user  102 Nov 30 23:59 content
drwxr-xr-x  2 user   68 Nov 30 23:58 data
drwxr-xr-x  2 user   68 Nov 30 23:58 layouts
drwxr-xr-x  2 user   68 Nov 30 23:58 static
drwxr-xr-x  6 user  204 Dec  1 00:20 themes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The directory has 6 sub-directories and 1 file. Let&amp;rsquo;s look at each one of them:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;archetypes: You can create new content files in Hugo using the &lt;code&gt;hugo new&lt;/code&gt; command.
When you run that command, it adds few configuration properties to the post like date and title.
Archetype allows you to define your own configuration properties that will be added to the post front matter whenever &lt;code&gt;hugo new&lt;/code&gt; command is used.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;config.toml: Every website should have a configuration file at the root.
By default, the configuration file uses &lt;code&gt;TOML&lt;/code&gt; format but you can also use &lt;code&gt;YAML&lt;/code&gt; or &lt;code&gt;JSON&lt;/code&gt; formats as well.
&lt;code&gt;TOML&lt;/code&gt; is minimal configuration file format that’s easy to read due to obvious semantics.
The configuration settings mentioned in the &lt;code&gt;config.toml&lt;/code&gt; are applied to the full site.
These configuration settings include &lt;code&gt;baseurl&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; of the website.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;content: This is where you will store content of the website.
Inside &lt;code&gt;content&lt;/code&gt;, you will create sub-directories for different sections.
Let’s suppose your website has three actions – blog, article, and tutorial then you will have three different directories for each of them inside the content directory.
The name of the section i.e. blog, article, or tutorial will be used by Hugo to apply a specific layout applicable to that section.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;data: This directory is used to store configuration files that can be used by Hugo when generating your website.
You can write these files in &lt;code&gt;YAML&lt;/code&gt;, &lt;code&gt;JSON&lt;/code&gt;, or &lt;code&gt;TOML&lt;/code&gt; format.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;layouts: The content inside this directory is used to specify how your content will be converted into the static website.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;static: This directory is used to store all the static content that your website will need like images, CSS, JavaScript or other static content.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;step-2-create-contents&#34;&gt;Step 2: Create contents&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s add a new post to our &lt;code&gt;blog&lt;/code&gt;. We will use the &lt;code&gt;hugo new&lt;/code&gt; command to create a new post.
In our example, we want to create a welcome post to greet users visiting our blog.
Make sure you are inside the &lt;code&gt;blog&lt;/code&gt; directory and type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo new post/welcome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a new directory &lt;code&gt;post&lt;/code&gt; inside the &lt;code&gt;content&lt;/code&gt; directory, and a new file named &lt;code&gt;welcome.md&lt;/code&gt; inside it.&lt;/p&gt;

&lt;p&gt;The content of &lt;code&gt;welcome.md&lt;/code&gt; will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
draft = true
title = &amp;quot;welcome&amp;quot;
date = &amp;quot;2016-12-01T00:22:59+01:00&amp;quot;

+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The content inside &lt;code&gt;+++&lt;/code&gt; is the TOML configuration for the post.
This configuration is called &lt;strong&gt;front matter&lt;/strong&gt;.
It enables you to define post configuration along with its content.
By default, each post will have the three configuration properties shown above.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s add a short welcome message:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
draft = true
title = &amp;quot;welcome&amp;quot;
date = &amp;quot;2016-12-01T00:22:59+01:00&amp;quot;

+++

Welcome to my blog!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-3-serve-content&#34;&gt;Step 3: Serve content&lt;/h2&gt;

&lt;p&gt;Hugo has an inbuilt server that can serve your website content so that you can preview it.
You can also use the inbuilt Hugo server in production.
Place yourself in the &lt;code&gt;blog&lt;/code&gt; directory and run&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output will read&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 of 1 draft rendered
0 future content
0 pages created
0 paginator pages created
0 tags created
0 categories created
in 9 ms
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can view your blog at &lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;, go check it out&amp;hellip; it&amp;rsquo;s a blank page.
That&amp;rsquo;s because:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;As you can see in the &lt;code&gt;hugo server&lt;/code&gt; command output, Hugo didn’t render the draft.
Hugo will only render drafts if you pass the &lt;code&gt;buildDrafts&lt;/code&gt; flag to the hugo server command.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;We have to specify a theme that Hugo can use to render the content.
We will do that in the next step.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To render drafts, run &lt;code&gt;hugo server --buildDrafts&lt;/code&gt; and head back to &lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt;.
Yet another wonderful blank page. We are missing the theme, remember that?&lt;/p&gt;

&lt;h2 id=&#34;step-4-add-theme&#34;&gt;Step 4: Add theme&lt;/h2&gt;

&lt;p&gt;Themes provide the layout and templates that will be used by Hugo to render your website.
There are a lot of open-source themes available &lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;here&lt;/a&gt; that you can use.&lt;/p&gt;

&lt;p&gt;In order to add a theme move to the &lt;code&gt;themes&lt;/code&gt; directory inside the root of your website and clone a theme for your website.
For our example, we will use the &lt;code&gt;bleak&lt;/code&gt; theme.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Inside the themes directory&lt;/strong&gt; run &lt;code&gt;git clone https://github.com/Zenithar/hugo-theme-bleak.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Get back to the &lt;code&gt;blog&lt;/code&gt; directory (&lt;code&gt;cd ..&lt;/code&gt;) and run &lt;code&gt;hugo server --theme=hugo-theme-bleak --buildDrafts&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Go to &lt;a href=&#34;http://localhost:1313&#34;&gt;http://localhost:1313&lt;/a&gt; and enjoy your freshly crafted blog.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s get back to code and try to understand how themes work, in order to customize and modify them.
A theme consist of the following:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;theme.toml&lt;/strong&gt; is the theme configuration file that gives information about the theme like name and description of theme, author details, and theme license.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;images&lt;/strong&gt; directory contains four images, &lt;code&gt;screenshot.png&lt;/code&gt;, &lt;code&gt;tn.png&lt;/code&gt;, &lt;code&gt;full_blog.png&lt;/code&gt; and &lt;code&gt;full_post.png&lt;/code&gt;.
These images are examples of what the theme looks like;
as an example &lt;code&gt;screenshot.png&lt;/code&gt; is the image of the list view and &lt;code&gt;tn.png&lt;/code&gt; is the single post view.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;layouts&lt;/strong&gt; directory contains different views for different content types.
Every content type should have two files &lt;code&gt;single.html&lt;/code&gt; and &lt;code&gt;list.html&lt;/code&gt;.
&lt;code&gt;single.html&lt;/code&gt; is used for rendering a single piece of content.
&lt;code&gt;list.html&lt;/code&gt; is used to view a list of content items.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;static&lt;/strong&gt; directory stores all the static assets used by the template.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Obviously you can clone multiple themes and test theme using the &lt;code&gt;--theme&lt;/code&gt; argument.&lt;/p&gt;

&lt;h2 id=&#34;step-5-update-config-file&#34;&gt;Step 5: Update config file&lt;/h2&gt;

&lt;p&gt;The website uses the dummy values specified in &lt;code&gt;blog/config.toml&lt;/code&gt;.
Let’s update the configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl = &amp;quot;https://mywebsite.com&amp;quot;
title = &amp;quot;My blog&amp;quot;
languageCode = &amp;quot;en-us&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;optional-add-comments&#34;&gt;Optional: Add comments&lt;/h3&gt;

&lt;p&gt;To integrate comments in your blog you can use &lt;strong&gt;Disqus&lt;/strong&gt;. Just open the &lt;code&gt;blog/config.toml&lt;/code&gt; file and add&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[Params]
  disqusShortname = &amp;lt;your disqus shortname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, commenting will be enabled in your blog.&lt;/p&gt;

&lt;h2 id=&#34;step-6-make-post-public&#34;&gt;Step 6: Make post public&lt;/h2&gt;

&lt;p&gt;Our welcome post is still in &lt;code&gt;draft&lt;/code&gt; status.
To make a draft public, you can either run this command&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo undraft content/post/welcome.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or manually change the draft status in the post to &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now you can start the server without the &lt;code&gt;buildDrafts&lt;/code&gt; argument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo server --theme=hugo-theme-bleak
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;step-7-generate-website&#34;&gt;Step 7: Generate website&lt;/h2&gt;

&lt;p&gt;To generate Hugo website source you can use to deploy your website on GitHub pages,
first edit &lt;code&gt;blog/config.toml&lt;/code&gt;, changing the baseurl line to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;baseurl = &amp;quot;https://username.github.io/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then type&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo --theme=hugo-theme-bleak
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this command, a &lt;code&gt;public&lt;/code&gt; folder will be created, containing teh generated source.&lt;/p&gt;

&lt;h2 id=&#34;step-8-go-public&#34;&gt;Step 8: Go public&lt;/h2&gt;

&lt;p&gt;On the github side of the thing, create a new &lt;strong&gt;empty&lt;/strong&gt; (no README) repo named &lt;code&gt;username.github.io&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now move to the &lt;code&gt;public&lt;/code&gt; directory and add version control.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git init
git remote add origin https://github.com/username/username.github.io.git
git add --all
git commit -m &amp;quot;First commit&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Visit &lt;strong&gt;&lt;a href=&#34;https://username.github.io/&#34;&gt;https://username.github.io/&lt;/a&gt;&lt;/strong&gt; and enjoy your blog, now available online.&lt;/p&gt;

&lt;p&gt;Anytime, you can regenerate the site with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hugo --theme=hugo-theme-bleak
cd public
git add --all
git commit -m &amp;quot;&amp;lt;some change message&amp;gt;&amp;quot;
git push origin master
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>